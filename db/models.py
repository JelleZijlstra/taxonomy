# http://stackoverflow.com/questions/372885/how-do-i-connect-to-a-mysql-database-in-python
# generated by pwiz.py
from peewee import (
    MySQLDatabase, Model, IntegerField, CharField, ForeignKeyField, TextField, BooleanField
)
import getinput
import json
import operator
import peewee
import re
import sys
import traceback
import warnings

# warnings.filterwarnings('error')

from . import constants
from . import definition
from . import ehphp
from . import helpers
from . import settings

database = MySQLDatabase(settings.DATABASE, user=settings.USER, passwd=settings.PASSWD, charset='utf8')


class BaseModel(Model):
    class Meta(object):
        database = database

    def dump_data(self):
        return "%s(%r)" % (self.__class__.__name__, self.__dict__)

    def full_data(self):
        for field in sorted(self.fields()):
            value = getattr(self, field)
            if value is not None:
                print("{}: {}".format(field, value))

    def s(self, **kwargs):
        """Set attributes on the object.

        Use this in the shell instead of directly assigning properties because that does
        not automatically save the object. This is especially problematic if one does
        something like `Oryzomys.base_name.authority = 'Smith'`, because `Oryzomys.base_name`
        creates a temporary object that is immediately thrown away.

        """
        for name, value in kwargs.items():
            setattr(self, name, value)
        self.save()

    def __del__(self):
        if self.is_dirty():
            self.save()

    @classmethod
    def fields(cls):
        for field in dir(cls):
            if isinstance(getattr(cls, field), peewee.Field):
                yield field


class Taxon(BaseModel):
    rank = IntegerField()
    valid_name = CharField(default='')
    age = IntegerField()
    parent = ForeignKeyField('self', related_name='children', null=True, db_column='parent_id')
    comments = TextField(null=True)
    data = TextField(null=True)
    is_page_root = BooleanField(default=False)
    base_name_id = IntegerField(null=True)

    class Meta(object):
        db_table = 'taxon'

    name = property(lambda self: self.base_name)

    def group(self):
        return helpers.group_of_rank(self.rank)

    def sorted_names(self, exclude_valid=False):
        names = self.names
        if exclude_valid:
            names = filter(lambda name: name.status != constants.STATUS_VALID, names)
        return sorted(names, key=operator.attrgetter('status', 'root_name'))

    def sorted_children(self):
        children = self.children
        return sorted(children, key=operator.attrgetter('rank', 'valid_name'))

    def root_name(self):
        return self.valid_name.split(' ')[-1]

    def full_name(self):
        if self.rank == constants.SUBGENUS:
            return self.parent.valid_name + ' (' + self.valid_name + ')'
        if self.rank == constants.SPECIES_GROUP:
            return self.parent.full_name() + ' (' + self.base_name.root_name + ')'
        elif self.rank == constants.SPECIES:
            if self.parent.rank > constants.GENUS:
                return self.valid_name
            parent_name = self.parent.full_name()
            if self.parent.needs_is():
                parent_name += " (?)"
            return parent_name + " " + self.base_name.root_name
        elif self.rank == constants.SUBSPECIES:
            return self.parent.full_name() + " " + self.base_name.root_name
        else:
            return self.valid_name

    def needs_is(self):
        if not hasattr(self, '_needs_is'):
            if self.rank == constants.SUBGENUS:
                self._needs_is = Taxon.select().where(Taxon.parent == self, Taxon.rank == constants.SPECIES_GROUP).count() > 0
            elif self.rank == constants.GENUS:
                self._needs_is = Taxon.select().where(Taxon.parent == self, (Taxon.rank == constants.SUBGENUS) | (Taxon.rank == constants.SPECIES_GROUP)).count() > 0
            else:
                self._needs_is = False
        return self._needs_is

    def parent_of_rank(self, rank, original_taxon=None):
        if original_taxon is None:
            original_taxon = self
        if self.rank > rank:
            raise ValueError("%s has no ancestor of rank %s" % (original_taxon, constants.string_of_rank(rank)))
        elif self.rank == rank:
            return self
        else:
            return self.parent.parent_of_rank(rank, original_taxon=original_taxon)

    def is_child_of(self, taxon):
        if self == taxon:
            return True
        elif self.parent is None:
            return False
        else:
            return self.parent.is_child_of(taxon)

    def children_of_rank(self, rank, age=None):
        if self.rank < rank:
            return []
        elif self.rank == rank:
            if age is None or self.age == age:
                return [self]
            else:
                return []
        else:
            out = []
            for child in self.children:
                out += child.children_of_rank(rank, age=age)
            return out

    def find_names(self, root_name, group=None, fuzzy=True):
        """Find instances of the given root_name within the given container taxon."""
        if fuzzy:
            query = Name.root_name % root_name
        else:
            query = Name.root_name == root_name  # LIKE
        candidates = Name.filter(query)

        result = []
        # maybe I could do some internal caching here but for now this is fast enough
        for candidate in candidates:
            if group is not None and candidate.group != group:
                continue
            taxon = candidate.taxon
            while taxon.parent is not None:
                if taxon.id == self.id:
                    result.append(candidate)
                    break
                taxon = taxon.parent
        return result

    def display(self, full=False, max_depth=None, file=sys.stdout, depth=0):
        file.write(' ' * (4 * depth))
        file.write('%s %s (%s)\n' % (constants.string_of_rank(self.rank), self.full_name(), constants.string_of_age(self.age)))
        if full:
            data = {
                'comments': self.comments,
                'data': self.data,
                'is_page_root': self.is_page_root,
            }
            for key, value in data.items():
                if value:
                    file.write(' ' * ((depth + 1) * 4))
                    file.write('%s: %s\n' % (key, value))
        for name in self.sorted_names():
            file.write(name.display(depth=depth + 1, full=full))
        if max_depth is None or max_depth > 0:
            new_max_depth = None if max_depth is None else max_depth - 1
            for child in self.sorted_children():
                child.display(file=file, depth=depth + 1, max_depth=new_max_depth, full=full)

    def add(self, rank, name, authority=None, year=None, age=None, type=False, **kwargs):
        if age is None:
            age = self.age
        taxon = Taxon.create(valid_name=name, age=age, rank=rank, parent=self)
        kwargs['group'] = helpers.group_of_rank(rank)
        kwargs['root_name'] = helpers.root_name_of_name(name, rank)
        name = Name.create(status=constants.STATUS_VALID, taxon=taxon, **kwargs)
        if authority is not None:
            name.authority = authority
        if year is not None:
            name.year = year
        name.save()
        taxon.base_name = name
        if type:
            self.base_name.type = name
            self.save()
        taxon.save()
        return taxon

    def add_syn(self, root_name, authority=None, year=None, original_name=None, original_citation=None, page_described=None, status=constants.STATUS_SYNONYM, **kwargs):
        kwargs['root_name'] = root_name
        kwargs['authority'] = authority
        kwargs['year'] = year
        # included in the method signature so they autocomplete in shell
        kwargs['original_name'] = original_name
        kwargs['original_citation'] = original_citation
        kwargs['page_described'] = page_described
        kwargs['status'] = status
        kwargs['taxon'] = self
        if 'group' not in kwargs:
            kwargs['group'] = self.base_name.group
        return Name.create(**kwargs)

    def add_type_identical(self, name, page_described=None):
        """Convenience method to add a type species described in the same paper as the genus."""
        assert self.rank == constants.GENUS
        assert self.base_name.type is None
        full_name = '%s %s' % (self.valid_name, name)
        result = self.add(
            constants.SPECIES, full_name, type=True, authority=self.base_name.authority, year=self.base_name.year,
            original_citation=self.base_name.original_citation, original_name=full_name, page_described=page_described)
        self.base_name.type = result.base_name
        self.save()
        return result

    def from_paper(self, rank, name, paper, page_described=None, **override_kwargs):
        authority, year = ehphp.call_ehphp('taxonomicAuthority', [paper])
        result = self.add(
            rank=rank, name=name, original_citation=paper, page_described=page_described,
            original_name=name, authority=authority, year=year, parent=self,
        )
        result.s(**override_kwargs)
        return result

    def add_nominate(self):
        if self.rank == constants.SPECIES:
            rank = constants.SUBSPECIES
        elif self.rank == constants.GENUS:
            rank = constants.SUBGENUS
        elif self.rank == constants.TRIBE:
            rank = constants.SUBTRIBE
        elif self.rank == constants.SUBFAMILY:
            rank = constants.TRIBE
        elif self.rank == constants.FAMILY:
            rank = constants.FAMILY
        else:
            assert False, 'Cannot add nominate subtaxon of %s of rank %s' % (self, helpers.string_of_rank(self.rank))

        taxon = Taxon.create(age=self.age, rank=rank, parent=self)
        taxon.base_name = self.base_name
        taxon.recompute_name()
        return taxon

    def syn(self, name=None, **kwargs):
        """Find a synonym matching the given arguments."""
        if name is not None:
            kwargs['root_name'] = name
        for candidate in self.sorted_names():
            for key, value in kwargs.items():
                if getattr(candidate, key) != value:
                    break
            else:
                return candidate
        else:
            return None

    def open_description(self):
        return self.base_name.open_description()

    def compute_valid_name(self):
        name = self.base_name
        if name.group in (constants.GROUP_GENUS, constants.GROUP_HIGH):
            return name.root_name
        elif name.group == constants.GROUP_FAMILY:
            return name.root_name + helpers.suffix_of_rank(self.rank)
        else:
            assert name.group == constants.GROUP_SPECIES
            try:
                genus = self.parent_of_rank(constants.GENUS)
            except ValueError:
                # if there is no genus, just use the original name
                # this may be one case where we can't rely on the computed valid name
                assert self.rank == constants.SPECIES
                return self.base_name.original_name
            else:
                if self.rank == constants.SPECIES_GROUP:
                    return '%s (%s)' % (genus.base_name.root_name, name.root_name)
                elif self.rank == constants.SPECIES:
                    return '%s %s' % (genus.base_name.root_name, name.root_name)
                else:
                    assert self.rank == constants.SUBSPECIES, "Unexpected rank %s" % constants.string_of_rank(self.rank)
                    species = self.parent_of_rank(constants.SPECIES)
                    return '%s %s %s' % (genus.base_name.root_name, species.base_name.root_name, name.root_name)

    def recompute_name(self):
        new_name = self.compute_valid_name()
        if new_name != self.valid_name:
            print('Changing valid name: %s -> %s' % (self.valid_name, new_name))
            self.valid_name = new_name
            self.save()

    def synonymize(self, to_taxon):
        if self.comments is not None:
            print("Warning: removing comments: %s" % self.comments)
        if self.data is not None:
            print("Warning: removing data: %s" % self.data)
        for child in self.children:
            child.parent = to_taxon
        self.base_name.status = constants.STATUS_SYNONYM
        for name in self.names:
            name.taxon = to_taxon
        self.delete_instance()

    def make_species_group(self):
        if self.parent.rank == constants.SPECIES_GROUP:
            parent = self.parent.parent
        else:
            parent = self.parent
        new_taxon = Taxon.create(rank=constants.SPECIES_GROUP, age=self.age, parent=parent)
        new_taxon.base_name = self.base_name
        new_taxon.recompute_name()
        self.parent = new_taxon
        self.save()
        return new_taxon

    def run_on_self_and_children(self, callback):
        callback(self)
        for child in self.children:
            child.run_on_self_and_children(callback)

    def remove(self):
        if self.children.count() != 0:
            print('Cannot remove %s since it has unremoved children' % self)
            return
        print('Removing taxon %s' % self)
        for name in self.sorted_names():
            name.remove()
        self.delete_instance()

    def __str__(self):
        return self.valid_name

    def __repr__(self):
        return str(self)

    def __getattr__(self, attr):
        """Returns a name belonging to this taxon with the given root_name or original_name."""
        candidates = [name for name in self.sorted_names() if name.root_name == attr or name.original_name == attr]
        if len(candidates) == 1:
            return candidates[0]
        elif len(candidates) == 0:
            raise AttributeError(attr)
        else:
            raise Name.DoesNotExist("Candidates: {}".format(candidates))

    def __dir__(self):
        result = set(super(Model, self).__dir__())
        names = self.sorted_names()
        result |= set(name.original_name for name in names)
        result |= set(name.root_name for name in names)
        result = [name for name in result if name is not None and ' ' not in name]
        return result

definition.taxon_cls = Taxon


class Name(BaseModel):
    root_name = CharField()
    group = IntegerField()
    status = IntegerField()
    taxon = ForeignKeyField(Taxon, related_name='names', db_column='taxon_id')
    authority = CharField(null=True)
    data = TextField(null=True)
    nomenclature_comments = TextField(null=True)
    original_citation = CharField(null=True)
    original_name = CharField(null=True)
    other_comments = TextField(null=True)
    page_described = CharField(null=True)
    stem = CharField(null=True)
    gender = IntegerField()
    taxonomy_comments = TextField(null=True)
    type = ForeignKeyField('self', null=True, db_column='type_id')
    verbatim_type = CharField(null=True)
    verbatim_citation = CharField(null=True)
    year = CharField(null=True)
    _definition = CharField(null=True, db_column='definition')

    @property
    def definition(self):
        data = self._definition
        if data is None:
            return None
        else:
            return definition.Definition.unserialize(data)

    @definition.setter
    def definition(self, definition):
        self._definition = definition.serialize()

    class Meta(object):
        db_table = 'name'

    def add_additional_data(self, new_data):
        '''Add data to the "additional" field within the "data" field'''
        data = json.loads(self.data)
        if 'additional' not in data:
            data['additional'] = []
        data['additional'].append(new_data)
        self.data = json.dumps(data)
        self.save()

    def add_data(self, field, value):
        if self.data is None or self.data == '':
            data = {}
        else:
            data = json.loads(self.data)
        data[field] = value
        self.data = json.dumps(data)

    def description(self):
        if self.original_name:
            out = self.original_name
        else:
            out = self.root_name
        if self.authority:
            out += " %s" % self.authority
        if self.year:
            out += ", %s" % self.year
        out += " (= %s)" % self.taxon.valid_name
        return out

    def is_unavailable(self):
        # TODO: generalize this
        return self.nomenclature_comments is not None and \
            'Unavailable because not based on a generic name.' in self.nomenclature_comments

    def display(self, full=False, depth=0):
        if self.original_name is None:
            out = self.root_name
        else:
            out = self.original_name
        if self.authority is not None:
            out += ' %s' % self.authority
        if self.year is not None:
            out += ', %s' % self.year
        if self.page_described is not None:
            out += ':%s' % self.page_described
        if self.original_citation is not None:
            out += ' {%s}' % self.original_citation
        if self.type is not None:
            out += ' (type: %s)' % self.type
        out += ' (%s)' % (constants.string_of_status(self.status))
        if full and (self.original_name is not None or self.stem is not None or self.gender is not None):
            parts = []
            if self.original_name is not None:
                parts.append('root: %s' % self.root_name)
            if self.stem is not None:
                parts.append('stem: %s' % self.stem)
            if self.gender is not None:
                parts.append(constants.Gender(self.gender).name)
            out += ' (%s)' % '; '.join(parts)
        if self.is_well_known():
            intro_line = getinput.green(out)
        else:
            intro_line = getinput.red(out)
        result = ' ' * ((depth + 1) * 4) + intro_line + '\n'
        if full:
            data = {
                'nomenclature_comments': self.nomenclature_comments,
                'other_comments': self.other_comments,
                'taxonomy_comments': self.taxonomy_comments,
                'verbatim_type': self.verbatim_type,
                'verbatim_citation': self.verbatim_citation,
            }
            result = ''.join([result] + [
                ' ' * ((depth + 2) * 4) + '%s: %s\n' % (key, value)
                for key, value in data.items()
                if value
            ])
        return result

    def is_well_known(self):
        """Returns whether all necessary attributes of the name have been filled in."""
        if self.authority is None or self.year is None or self.page_described is None or self.original_citation is None or self.original_name is None:
            return False
        elif self.group in (constants.GROUP_FAMILY, constants.GROUP_GENUS) and self.type is None:
            return False
        elif self.group == constants.GROUP_GENUS and (self.stem is None or self.gender is None):
            return False
        else:
            return True

    def validate(self):
        assert self.status != constants.STATUS_VALID
        old_taxon = self.taxon
        parent_group = helpers.group_of_rank(old_taxon.rank)
        if self.group == constants.GROUP_SPECIES and parent_group != constants.GROUP_SPECIES:
            new_rank = constants.SPECIES
            parent = old_taxon
        elif self.group == constants.GROUP_GENUS and parent_group != constants.GROUP_GENUS:
            new_rank = constants.GENUS
            parent = old_taxon
        elif self.group == constants.GROUP_FAMILY and parent_group != constants.GROUP_FAMILY:
            new_rank = constants.FAMILY
            parent = old_taxon
        else:
            new_rank = old_taxon.rank
            parent = old_taxon.parent
        new_taxon = Taxon.create(rank=new_rank, parent=parent, age=old_taxon.age, valid_name='')
        new_taxon.base_name = self
        new_taxon.valid_name = new_taxon.compute_valid_name()
        new_taxon.save()
        self.taxon = new_taxon
        self.status = constants.STATUS_VALID
        self.save()
        return new_taxon

    def open_description(self):
        if self.original_citation is None:
            print("%s: original citation unknown" % self.description())
        else:
            ehphp.call_ehphp('openf', [self.original_citation])

    def remove(self):
        print("Deleting name: " + self.description())
        self.delete_instance()
        return True

    def original_valid(self):
        assert self.original_name is None
        assert self.status == constants.STATUS_VALID
        self.original_name = self.taxon.valid_name

    def __str__(self):
        return self.description()

    def __repr__(self):
        return self.description()

    def detect_and_set_type(self, verbatim_type=None, verbose=False):
        if verbatim_type is None:
            verbatim_type = self.verbatim_type
        if verbose:
            print('=== Detecting type for %s from %s' % (self, verbatim_type))
        candidates = self.detect_type(verbatim_type=verbatim_type, verbose=verbose)
        if candidates is None or len(candidates) == 0:
            print("Verbatim type %s for name %s could not be recognized" % (verbatim_type, self))
            return False
        elif len(candidates) == 1:
            if verbose:
                print('Detected type: %s' % candidates[0])
            self.type = candidates[0]
            self.save()
            return True
        else:
            print("Verbatim type %s for name %s yielded multiple possible names: %s" % (verbatim_type, self, candidates))
            return False

    def detect_type(self, verbatim_type=None, verbose=False):
        def cleanup(name):
            return re.sub(r'\s+', ' ', name.strip().rstrip('.').replace('<i>', '').replace('</i>', ''))

        steps = [
            lambda verbatim: verbatim,
            lambda verbatim: re.sub(r'\([^)]+\)', '', verbatim),
            lambda verbatim: re.sub(r'=.*$', '', verbatim),
            lambda verbatim: re.sub(r'\(.*$', '', verbatim),
            lambda verbatim: re.sub(r'\[.*$', '', verbatim),
            lambda verbatim: re.sub(r',.*$', '', verbatim),
            lambda verbatim: self._split_authority(verbatim)[0],
            lambda verbatim: verbatim.split()[1] if ' ' in verbatim else verbatim,
            lambda verbatim: helpers.convert_gender(verbatim, constants.Gender.masculine),
            lambda verbatim: helpers.convert_gender(verbatim, constants.Gender.feminine),
            lambda verbatim: helpers.convert_gender(verbatim, constants.Gender.neuter),
        ]
        if verbatim_type is None:
            verbatim_type = self.verbatim_type
        candidates = None
        for step in steps:
            new_verbatim = cleanup(step(verbatim_type))
            if verbatim_type != new_verbatim or candidates is None:
                if verbose:
                    print('Trying verbatim type: %s' % new_verbatim)
                verbatim_type = new_verbatim
                candidates = self.detect_type_from_verbatim_type(verbatim_type)
                if len(candidates) > 0:
                    return candidates
        return []

    def _split_authority(self, verbatim_type):
        # if there is an uppercase letter following an all-lowercase word (the species name),
        # the authority is included
        find_authority = re.match(r'^(.* [a-z]+) ([A-Z+].+)$', verbatim_type)
        if find_authority:
            return find_authority.group(1), find_authority.group(2)
        else:
            return verbatim_type, None

    def detect_type_from_verbatim_type(self, verbatim_type):
        def _filter_by_authority(candidates, authority):
            if authority is None:
                return candidates
            split = re.split(r', (?=\d)', authority, maxsplit=1)
            if len(split) == 1:
                author, year = authority, None
            else:
                author, year = split
            result = []
            for candidate in candidates:
                if candidate.authority != authority:
                    continue
                if year is not None and candidate.year != year:
                    continue
                result.append(candidate)
            return result

        parent = self.taxon
        if self.group == constants.GROUP_FAMILY:
            verbatim = verbatim_type.split(maxsplit=1)
            if len(verbatim) == 1:
                type_name, authority = verbatim, None
            else:
                type_name, authority = verbatim
            return _filter_by_authority(parent.find_names(verbatim[0], group=constants.GROUP_GENUS), authority)
        else:
            type_name, authority = self._split_authority(verbatim_type)
            if ' ' not in type_name:
                root_name = type_name
                candidates = Name.filter(Name.root_name == root_name, Name.group == constants.GROUP_SPECIES)
                find_abbrev = False
            else:
                find_abbrev = re.match(r'^[A-Z]\. ([a-z]+)$', type_name)
                if find_abbrev:
                    root_name = find_abbrev.group(1)
                    candidates = Name.filter(Name.root_name == root_name, Name.group == constants.GROUP_SPECIES)
                else:
                    candidates = Name.filter(Name.original_name == type_name, Name.group == constants.GROUP_SPECIES)
            # filter by authority first because it's cheaper
            candidates = _filter_by_authority(candidates, authority)
            candidates = [candidate for candidate in candidates if candidate.taxon.is_child_of(parent)]
            # if we failed to find using the original_name, try the valid_name
            if len(candidates) == 0 and not find_abbrev:
                candidates = Name.filter(Name.status == constants.STATUS_VALID).join(Taxon).where(Taxon.valid_name == type_name)
                candidates = _filter_by_authority(candidates, authority)
                candidates = [candidate for candidate in candidates if candidate.taxon.is_child_of(parent)]
            return candidates

    @classmethod
    def find_name(cls, name, rank=None, authority=None, year=None):
        '''Find a Name object corresponding to the given information'''
        if rank is None:
            group = None
            initial_lst = cls.select().where(cls.root_name == name)
        else:
            group = helpers.group_of_rank(rank)
            if group == constants.GROUP_FAMILY:
                root_name = helpers.strip_rank(name, rank, quiet=True)
            else:
                root_name = name
            initial_lst = cls.select().where(cls.root_name == root_name, cls.group == group)
        for nm in initial_lst:
            if authority is not None and nm.authority and nm.authority != authority:
                continue
            if year is not None and nm.year and nm.year != year:
                continue
            if group == constants.GROUP_FAMILY:
                if nm.original_name and nm.original_name != name and initial_lst.count() > 1:
                    continue
            return nm
        raise cls.DoesNotExist

# Simulate peewee property
def _getter(self):
    try:
        return Name.get(Name.id == self.base_name_id)
    except Name.DoesNotExist:
        return None
def _setter(self, value):
    self.base_name_id = value.id
    Taxon.update(base_name_id=value.id).where(Taxon.id == self.id).execute()
    self.save()
Taxon.base_name = property(_getter, _setter)
